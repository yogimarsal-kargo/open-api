// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/kargotech/go-testapp/gen/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Mutation struct {
		CreateOrder func(childComplexity int, input model.NewOrder) int
		Health      func(childComplexity int) int
		UpdateOrder func(childComplexity int, input model.UpdateOrder) int
	}

	Order struct {
		ClientID    func(childComplexity int) int
		Destination func(childComplexity int) int
		ID          func(childComplexity int) int
		NumSales    func(childComplexity int) int
		OrderType   func(childComplexity int) int
		Origin      func(childComplexity int) int
		ProductID   func(childComplexity int) int
	}

	Query struct {
		Health func(childComplexity int) int
		Order  func(childComplexity int, input string) int
		Orders func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Mutation.createOrder":
		if e.complexity.Mutation.CreateOrder == nil {
			break
		}

		args, err := ec.field_Mutation_createOrder_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateOrder(childComplexity, args["input"].(model.NewOrder)), true

	case "Mutation.health":
		if e.complexity.Mutation.Health == nil {
			break
		}

		return e.complexity.Mutation.Health(childComplexity), true

	case "Mutation.updateOrder":
		if e.complexity.Mutation.UpdateOrder == nil {
			break
		}

		args, err := ec.field_Mutation_updateOrder_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateOrder(childComplexity, args["input"].(model.UpdateOrder)), true

	case "Order.clientID":
		if e.complexity.Order.ClientID == nil {
			break
		}

		return e.complexity.Order.ClientID(childComplexity), true

	case "Order.destination":
		if e.complexity.Order.Destination == nil {
			break
		}

		return e.complexity.Order.Destination(childComplexity), true

	case "Order.id":
		if e.complexity.Order.ID == nil {
			break
		}

		return e.complexity.Order.ID(childComplexity), true

	case "Order.numSales":
		if e.complexity.Order.NumSales == nil {
			break
		}

		return e.complexity.Order.NumSales(childComplexity), true

	case "Order.orderType":
		if e.complexity.Order.OrderType == nil {
			break
		}

		return e.complexity.Order.OrderType(childComplexity), true

	case "Order.origin":
		if e.complexity.Order.Origin == nil {
			break
		}

		return e.complexity.Order.Origin(childComplexity), true

	case "Order.productID":
		if e.complexity.Order.ProductID == nil {
			break
		}

		return e.complexity.Order.ProductID(childComplexity), true

	case "Query.health":
		if e.complexity.Query.Health == nil {
			break
		}

		return e.complexity.Query.Health(childComplexity), true

	case "Query.order":
		if e.complexity.Query.Order == nil {
			break
		}

		args, err := ec.field_Query_order_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Order(childComplexity, args["input"].(string)), true

	case "Query.orders":
		if e.complexity.Query.Orders == nil {
			break
		}

		return e.complexity.Query.Orders(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputNewOrder,
		ec.unmarshalInputUpdateOrder,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../graph/order.graphql", Input: `extend type Query {
  order(input: ID!): Order!
  orders: [Order!]!
}

extend type Mutation {
  createOrder(input: NewOrder!): Order!
  updateOrder(input: UpdateOrder!): Order!
}

type Order {
  id: ID!
  clientID: String!
  productID: String!
  numSales: Int!
  orderType: String!
  origin: String!
  destination: String!
}

input NewOrder {
  clientID: String!
  productID: String!
  numSales: Int!
  orderType: String!
  origin: String!
  destination: String!
}

input UpdateOrder {
    id: ID!
    numSales: Int!
}`, BuiltIn: false},
	{Name: "../../../graph/schema.graphql", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/


type Query {
  health: String!
}

type Mutation {
  health: String!
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
